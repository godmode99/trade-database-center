# แผนการพัฒนาโครงการ Trade Database Center

> เอกสารนี้เป็นแผนปฏิบัติการหลักของโปรเจค โดยขยายรายละเอียดเชิงระบบให้เห็นชัดว่าแต่ละส่วนมี **Input / Process / Output / Spec** อะไรบ้าง เพื่อให้ทีมพัฒนาและทีม data ใช้อ้างอิงร่วมกันได้ทันที

## 1) เป้าหมายเชิงส่งมอบ (Deliverables)
1. มี data pipeline ที่รันได้จริงสำหรับ Calendar, FRED, MT5, CME FedWatch
2. มีโครงสร้างฐานข้อมูลกลางบน Supabase พร้อม data contract ที่ชัดเจน
3. มีเว็บ Next.js สำหรับใช้งานข้อมูลหลักอย่างน้อย 1 Dashboard (MVP)
4. มี automation + logging + data quality check พร้อม runbook

## 2) สถาปัตยกรรมข้อมูล (Data Flow ภาพรวม)
1. **Source Layer (External)**
   - Calendar (ForexFactory)
   - FRED API
   - MT5 terminal
   - CME FedWatch (probabilities + quotes)
2. **Ingestion Layer (Python Fetch Jobs)**
   - รันเป็น job แยกตาม source/frequency
   - สร้างไฟล์ raw + run manifest + log
3. **Storage Layer (Supabase/Postgres)**
   - แยกโซนข้อมูล: `raw` → `normalized` → `features`
   - ใช้ upsert ตาม unique key
4. **Serving Layer (Web/API)**
   - Next.js query ข้อมูลจาก Supabase
   - แสดง dashboard/filter/timeframe
5. **Ops Layer**
   - scheduler, alert, quality checks, rerun workflow

## 3) Data Contract ราย source (Input / Output / Spec)

### 3.1 Calendar
**Input**
- URL ปฏิทินข่าวเศรษฐกิจ (เริ่มต้น `https://www.forexfactory.com/calendar?`)
- Config เงื่อนไขคัดข่าว: `currencies`, `impacts`, `days_back`, `days_forward`
- ข้อมูล session/cookie (กรณีต้องใช้ในการดึง document)

**Process หลัก**
1. capture html/json ที่เกี่ยวข้อง
2. extract event fields เป็นโครงสร้างมาตรฐาน
3. select เฉพาะ event ตาม rule
4. refresh ค่า `actual` เมื่อข่าวออก
5. compute surprise (actual - forecast) เมื่อครบข้อมูล

**Output**
- `raw.calendar_events` (ข้อมูลข่าวดิบ)
- `normalized.calendar_events` (field สะอาด + timezone เดียวกัน)
- `features.calendar_surprise` (surprise score/label)
- `run_manifest` + `logs`

**Spec สำคัญ**
- key ขั้นต่ำ: `source_event_id` หรือ composite (`event_time`, `currency`, `name`)
- timezone กลาง: UTC (เก็บ `event_time_utc`) และ optional `event_time_bkk` สำหรับ UI
- update mode: upsert ได้เมื่อ `actual` เปลี่ยนจากว่าง → มีค่า

### 3.2 FRED
**Input**
- API key (`FRED_API_KEY`)
- series list ตาม run mode: daily/weekly/monthly
- `observation_start`, timeout, retry policy

**Process หลัก**
1. request series observations
2. normalize date/value/frequency
3. validate null / duplicate / stale
4. upsert ลงตารางตามความถี่

**Output**
- `raw.fred_observations`
- `normalized.fred_series_latest` (มุมมองล่าสุดต่อ series)
- `run_manifest` + `error_report`

**Spec สำคัญ**
- unique key: (`series_id`, `observation_date`)
- value type: numeric (รองรับ null)
- บันทึก metadata: `fetch_time_utc`, `run_mode`, `source_status`

### 3.3 MT5
**Input**
- symbol list (เช่น EURUSD)
- timeframe list (M15/H4/D1/W1/MN1)
- bars ต่อ timeframe
- feature parameters (`pivot_left`, `pivot_right`, EMA window)

**Process หลัก**
1. ดึง OHLCV จาก MT5
2. normalize schema ของแท่งราคา
3. คำนวณ features (TR, ATR14, BOS/CHOCH, EMA, sweep ฯลฯ)
4. validate range/missing ratio

**Output**
- `raw.mt5_ohlcv`
- `features.mt5_price_features`
- summary/manifest/logs

**Spec สำคัญ**
- unique key: (`symbol`, `timeframe`, `bar_time_utc`)
- type ของราคา: numeric(18,8)
- volume: bigint
- ต้องระบุ `broker_time` และ `bar_time_utc` ชัดเจน

### 3.4 CME FedWatch
**Input**
- credentials/session สำหรับ CME
- watchlist filters ตาม daily/weekly/monthly
- probabilities config (SOFR, ZQ)

**Process หลัก**
1. login/session prepare
2. fetch quotes และ probabilities แยก endpoint
3. normalize contract code + expiry
4. upsert และเก็บ snapshot เวลา fetch

**Output**
- `raw.cme_quotes`
- `raw.cme_probabilities`
- `normalized.cme_contract_latest`
- manifest/logs/meta response

**Spec สำคัญ**
- unique key quotes: (`product_code`, `contract_month`, `asof_time_utc`)
- unique key probabilities: (`underlying`, `meeting_date`, `rate_bin`, `asof_time_utc`)
- เก็บ source hash เพื่อตรวจความต่างของ snapshot

## 4) Supabase Schema v1 (สเปกขั้นต่ำ)

### 4.1 Naming & Zone
- schema group: `raw`, `normalized`, `features`, `ops`
- ชื่อคอลัมน์มาตรฐาน:
  - เวลา: `*_utc` (timestamp with time zone)
  - แหล่งที่มา: `source`, `source_ref`
  - ตรวจสอบย้อนหลัง: `ingested_at_utc`, `run_id`

### 4.2 ตารางขั้นต่ำที่ต้องมี
- `ops.pipeline_runs`
  - `run_id (pk)`, `pipeline_name`, `run_mode`, `started_at_utc`, `ended_at_utc`, `status`, `error_message`
- `raw.calendar_events`, `raw.fred_observations`, `raw.mt5_ohlcv`, `raw.cme_quotes`, `raw.cme_probabilities`
- `features.mt5_price_features`, `features.calendar_surprise`
- `normalized.*_latest` view สำหรับหน้าเว็บ

### 4.3 Index/Constraint ที่ต้องใส่ตั้งแต่เริ่ม
- unique index ตาม key ที่ระบุใน section 3
- index สำหรับ query UI:
  - calendar: `(event_time_utc desc, currency, impact)`
  - fred: `(series_id, observation_date desc)`
  - mt5: `(symbol, timeframe, bar_time_utc desc)`

## 5) แผนการพัฒนาแบบละเอียด (Phase + งานย่อย)

### Phase 1: Foundation (สัปดาห์ 1-2)
- [ ] ออกแบบ schema + migration script v1
- [ ] สร้าง `ops.pipeline_runs` และ format run_id กลาง
- [ ] ย้าย Calendar pipeline จาก ref เข้า `god project/fetch/calendar`
- [ ] สร้าง config ตัวอย่าง + `.env.example`
- [ ] ทดสอบ local run ของ Calendar end-to-end

**Acceptance Criteria**
- มี migration apply ได้บน Supabase
- Calendar ingest เข้า `raw.calendar_events` อย่างน้อย 1 run
- มี log และ run record ครบ

### Phase 2: Source Expansion (สัปดาห์ 3-4)
- [ ] FRED daily → weekly → monthly
- [ ] MT5 ohlcv + feature set หลัก
- [ ] CME quotes + probabilities
- [ ] เพิ่ม shared utility: retry, backoff, idempotent upsert

**Acceptance Criteria**
- ทั้ง 4 source ingest ได้ตามความถี่ขั้นต่ำ
- key ซ้ำไม่สร้างข้อมูลซ้ำ (พิสูจน์ด้วย rerun)

### Phase 3: Web & API (สัปดาห์ 5)
- [ ] สร้าง query layer บน Next.js (server-side)
- [ ] Dashboard MVP: calendar table + latest fred/mt5/cme cards
- [ ] filter/source/timeframe/date range
- [ ] API endpoint สำหรับโปรเจคภายนอกเรียกข้อมูลหลัก

**Acceptance Criteria**
- หน้าเว็บไม่ใช่ starter template
- ผู้ใช้ filter แล้วเห็นผลจาก DB จริง

### Phase 4: Automation & Quality (สัปดาห์ 6)
- [ ] ตั้ง scheduler แยก job ตาม source/frequency
- [ ] alert เมื่อ job fail หรือข้อมูล stale
- [ ] quality checks: missing, outlier, freshness, duplicate
- [ ] runbook: วิธี rerun / backfill / rollback

**Acceptance Criteria**
- มีรายงานสถานะรายวัน
- มีขั้นตอนแก้เหตุขัดข้องที่คนใหม่ทำตามได้

## 6) สเปก API/การใช้ข้อมูล (สำหรับเว็บและโปรเจคอื่น)

### 6.1 Endpoint ขั้นต่ำ (แนวทาง)
- `GET /api/calendar/events?from=&to=&currency=&impact=`
- `GET /api/fred/series/:series_id?limit=`
- `GET /api/mt5/bars?symbol=&timeframe=&limit=`
- `GET /api/cme/probabilities?underlying=&meeting_date=`

### 6.2 Response Contract ขั้นต่ำ
- มี field กลางทุก endpoint:
  - `run_id`
  - `asof_utc`
  - `source`
  - `data` (array/object)
- ข้อผิดพลาดใช้รูปแบบเดียวกัน:
  - `error.code`, `error.message`, `error.details`

## 7) Test Plan (ขั้นต่ำที่ต้องมี)
1. **Unit Test**
   - parser ของแต่ละ source
   - feature calculator (MT5)
2. **Integration Test**
   - fetch → normalize → upsert
3. **Data Quality Test**
   - duplicate key = 0
   - missing ratio ไม่เกิน threshold
   - ค่า timestamp ไม่หลุด timezone
4. **Smoke Test (Web)**
   - endpoint ตอบกลับภายใน SLA (เช่น < 1s สำหรับ latest view)

## 8) ความเสี่ยง + แผนบรรเทา
- Source เปลี่ยน schema กะทันหัน
  - แก้โดยแยก parser version + contract test
- Credential หมดอายุ/โดนบล็อก
  - แก้โดยมี health check และ fallback notification
- ข้อมูลโตเร็ว query ช้า
  - แก้โดยทำ partition/index/materialized view

## 9) Definition of Done (DoD)
งานของแต่ละ pipeline จะถือว่าเสร็จเมื่อ:
1. รันได้ตาม schedule ที่กำหนด
2. upsert ถูกต้องและ idempotent
3. มี run log + manifest + error report
4. ผ่าน quality checks ขั้นต่ำ
5. เว็บ/API อ่านและแสดงผลได้จริง

## 10) อัปเดตล่าสุด
- ปรับแผนให้ละเอียดระดับ Input/Output/Spec ราย source
- เพิ่มสเปก schema v1, API contract, test plan และ acceptance criteria ราย phase
- ยังคงลำดับเริ่มต้นที่ Calendar + Schema Foundation ก่อน source อื่น
